<%
// Creates a list of API Interfaces sorted alphabetically

const APIHref = $0 || '/en-US/docs/Web/API';

/**
 * Checks if the page is an interface page.
 *
 * @param {string} pageSlug
 * @param {string[]} [tags]
 */
function isInterface(pageSlug, tags = null) {
    const spaceIndex = pageSlug.indexOf('_');

    // If there are no spaces (represented by underscores), then we can
    // just return true, since this is by our rules an interface in that
    // situation.

    // Unless the slug is simply "Reference", which is because that page
    // used to host this macro, until it was moved to "Web/API".

    if ((spaceIndex == -1) && (pageSlug != "Reference")) {
        return true;
    }

    // If the character after the space is '(', then this is assumed to be an
    // interface with a qualifier after its name (such as "(Firefox OS)").
    // These are allowed to appear in the index.

    if ((spaceIndex < pageSlug.length-1) && (pageSlug[spaceIndex+1] == '(')) {
        return true;
    }

    // If we get to here, then it's probably not an interface.

    return containsTag(tags, 'Interface');
}

/**
 * Prepares the title of the link. This includes wrapping the appropriate
 * portion of the title with `<code>`.
 *
 * @param {string} base The page title
 * @param {string} slug The page slug without the parent
 *
 * @return {[string, string]}
 *         The first entry is the new appropriate portion wrapped with `<code>`.
 *         The second entry is the raw title text.
 */
function buildTitle(base, slug) {
    base = base.trim();
    var spaceIndex = base.indexOf(' ');

    // If there are no spaces in the page's title, the entire base
    // string is the title, so we just wrap the whole thing in <code> and
    // return it.

    if (spaceIndex == -1) {
        return [
            `<code>${mdn.escapeHTML(base)}</code>`,
            base,
        ];
    }

    // If the character after the space is '(', then this is assumed to be an
    // interface with a qualifier after its name (such as "(Firefox OS)").
    // These are allowed to appear in the index, but we end the <code> block
    // before the first space

    if ((spaceIndex < base.length-1) && (base[spaceIndex+1] == '(')) {
        return [
            `<code>${
                mdn.escapeHTML(base.substring(0, spaceIndex))
            }</code>${
                mdn.escapeHTML(base.substring(spaceIndex))
            }`,
            base,
        ];
    }

    const match = /^(?:API )?([^ ]+)(?: (?:-|Interface))?/i.exec(mdn.escapeHTML(base));
    if (match) {
        const result = match[1];
        return [
            `<code>${mdn.escapeHTML(result)}</code>`,
            result,
        ];
    }

    // Give up and return the slug
    return [
        `<code>${mdn.escapeHTML(slug)}</code>`,
        slug,
    ];
}

function containsTag(tagList, tag) {
    if (!tagList || tagList == undefined) return 0;
    tag = tag.toLowerCase();
    for (var i = 0, len = tagList.length; i < len; i++) {
        if (tagList[i].toLowerCase() == tag) return 1;
    }
    return 0;
}

const pages = await page.subpagesExpand(APIHref); // get subpages, including tags
const locale = env.locale;
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const numLetters = letters.length;
const numPages = pages.length;

let html = "";
let p = 0;

for (let i = 0; i < numLetters; i++) {
    const curLetter = letters[i];
    let insertedHeading = false; // Haven't done this letter's heading yet

    if (p < numPages) {
        do {
            const page = pages[p];
            let builtTitle, badge = "";
            let {
                tags,
                url,
                summary = null,
                title,
                slug,
            } = page;

            // Build the formatted title string; skip this page if it's not
            // an interface.

            slug = slug.replace('Web/API/', '');
            if (!isInterface(slug, tags)) {
                p++;
                continue;
            }

            [
                builtTitle,
                title,
            ] = (buildTitle(title, slug));

            // add badges if needed

            if (containsTag(tags, "Non-standard") || containsTag(tags, "Non standard")) {
                badge = " " + await template("NonStandardBadge", ["1"]);
            }

            if (containsTag(tags, "Obsolete")) {
                badge += " " + await template("ObsoleteBadge", [1]);
            } else if (containsTag(tags, "Deprecated")) {
                badge += " " + await template("DeprecatedBadge", [1]);
            }

            if (containsTag(tags, "Experimental")) {
                badge += " " + await template("ExperimentalBadge", ["1"]);
            }

            // Wrap the badges in another span

            if (badge.length) badge = '<span class="indexListBadges">' + badge + "</span>";

            if (title[0].toUpperCase() == curLetter) {
                if (!containsTag(tags, "junk")) {
                    if (!insertedHeading) {
                        html += "\t<span>" + curLetter + "</span>\n\t<ul>";
                        insertedHeading = true;
                    }
                    html += '\n\t\t<li>' +
                        '<span class="indexListRow">' +
                            '<span class="indexListTerm">' +
                                '<a href="' + url.replace("en-US", locale) + '"' +
                                    (summary ? ` title="${mdn.escapeQuotes(summary)}"` : '') +
                                    '>' +
                                    builtTitle +
                                '</a></span>' +
                            badge +
                        '</span></li>';
                }
                p++;
            } else {
                break;
            }
        } while (p < pages.length);
    }
    if (insertedHeading) {
        html += "\n\t</ul>";
    }
}


%><div class="index">
<%-html%>
</div>
